/**
 * CodeGeneratorAgent - Generates code content and modifications based on plans
 * Bridges the gap between TaskPlanner and CommandGenerator/CodeModifier
 */

import * as vscode from 'vscode';
import { BaseAgent, AgentOutput, CodeModification, CommandSpec } from '../core/AgentTypes';
import { TaskPlannerResult } from './TaskPlannerAgent';
import { CodePlannerResult } from './CodePlannerAgent';

export interface CodeGeneratorInput {
    taskPlan: TaskPlannerResult;
    codePlan: CodePlannerResult;
}

export interface CodeGeneratorResult {
    commands: any[]; // specific CommandSpec structure
    modifications: CodeModification[];
    generatedFiles: string[];
}

export class CodeGeneratorAgent extends BaseAgent<CodeGeneratorInput, CodeGeneratorResult> {
    constructor() {
        super({ name: 'CodeGenerator', timeout: 20000 });
    }

    async execute(input: CodeGeneratorInput): Promise<AgentOutput<CodeGeneratorResult>> {
        const startTime = Date.now();

        try {
            const commands: any[] = [];
            const modifications: CodeModification[] = [];
            const generatedFiles: string[] = [];

            // Process tasks to generate code
            for (const task of input.taskPlan.taskGraph) {
                if (task.filePath && !task.description.includes('mkdir')) {
                    // This task involves a file
                    const content = this.generateContentForFile(task.filePath, task.description, input.codePlan);
                    
                    // For now, we assume we are creating new files (CommandGenerator will handle it)
                    // In a real scenario, we'd check if file exists to decide between create vs modify
                    
                    // We generate a "create_file" command spec
                    // Note: We are creating a generic command spec that CommandGenerator can understand
                    // OR we can output direct file content that PipelineEngine can feed to CommandGenerator
                    
                    commands.push({
                        operation: 'create_file',
                        target: task.filePath,
                        content: content
                    });
                    
                    generatedFiles.push(task.filePath);
                }
            }

            const result: CodeGeneratorResult = {
                commands,
                modifications,
                generatedFiles
            };

            return this.createOutput('success', result, 0.8, startTime, {
                reasoning: `Generated content for ${generatedFiles.length} files based on task plan`
            });

        } catch (error) {
            return this.handleError(error as Error, startTime);
        }
    }

    /**
     * Generate content for a file based on its type and description
     */
    private generateContentForFile(filePath: string, description: string, codePlan: CodePlannerResult): string {
        const ext = filePath.split('.').pop()?.toLowerCase();
        const fileName = filePath.split('/').pop()?.split('.')[0] || 'Component';

        // 1. React Component
        if (filePath.includes('components/') && (ext === 'tsx' || ext === 'jsx')) {
            return `import React from 'react';

interface ${fileName}Props {
    // TODO: Define props
    children?: React.ReactNode;
}

export const ${fileName}: React.FC<${fileName}Props> = ({ children }) => {
    return (
        <div className="${fileName.toLowerCase()}-container">
            {/* TODO: Implement ${description} */}
            <h2>${fileName}</h2>
            {children}
        </div>
    );
};

export default ${fileName};`;
        }

        // 2. TypeScript/JavaScript File
        if (ext === 'ts' || ext === 'js') {
            if (filePath.includes('types/') || filePath.includes('interfaces')) {
                return `// Type definitions for ${fileName}
// Generated by Byte Coder

export interface I${fileName} {
    id: string;
    createdAt: Date;
    updatedAt: Date;
}
`;
            }

            if (filePath.includes('utils/') || filePath.includes('helpers')) {
                return `/**
 * Utility functions for ${fileName}
 */

export const process${fileName} = (data: any): void => {
    // TODO: Implement processing logic
    console.log('Processing', data);
};
`;
            }
        }

        // 3. CSS/Styles
        if (ext === 'css' || ext === 'scss') {
            return `/* Styles for ${fileName} */
.${fileName.toLowerCase()}-container {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}
`;
        }

        // 4. JSON Config
        if (ext === 'json') {
            return `{\n  "name": "${fileName}",\n  "version": "1.0.0"\n}`;
        }

        // Default
        return `// ${fileName}
// ${description}
// TODO: Implement this file
`;
    }
}
